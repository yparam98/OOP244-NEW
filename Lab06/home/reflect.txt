/******************************************/
/*  Student:    Yathavan Parameshwaran    */
/*  Student #:  070 692 140               */
/*  Assignment: Workshop 6.2: reflect.txt */
/*  Course:     OOP244 (retake)           */
/*  Professor:  Andrei Sajeniouk          */
/*  Date:       July 07, 2020             */
/******************************************/


Summary of Topics in this Workshop
**********************************

Class with Resources
    
    Simply put, a class with a resource is basically a class which has a dynamically allocated pointer as a data member. It is called a "resource" because it borrows "resources" from the host ocmputer like memory and processing power. When you allocate memory for a pointer, you are using up resources from the host computer, hence it is called class with resource.

Deep Copying

    There are two methods of copying, shallow and deep. Shallow copying is primarily reserved for data members that do not use up a host's resources. It is very simple copying, such as x1 = y1. Now, the other method is called deep copying. Deep copying is used whenever you need to copy data members that use resources, like pointers. You can do shallow copying on resource data members, but instead of copying values, it will simply copy the address of the original pointer that points to the values. This is not good, because if the original pointer changes or deletes the data, the pointer that is pointing to the original data's locations will reflect those changes, causing error. Deep copying is good because you actually copy over the data from the original pointer to the intended copy pointer. Deep copies of a class' data members are done through copy constructors and copy assignment operators, two topics that I will discuss next. 
        
Copy Constructors & Copy Assignment Operators

    Copy constructors and copy assignment operators are pretty much the same thing. Except when it isn't. Copy constructors are used for copying an object to a new object of the original type. Copy assignment operators are used to copy an object to an existing object of the original type. When I program, I tend to just call the copy assignment operator from the copy constructor, because they contain pretty much the same logic, but different use cases. In the copy constructor, I just do this: `*this = incomingObj;`. The "this" is a pointer to the current object, and since it is the copy constructor, it will normally refer to the NEW object. The incomingObj is the object that we want to copy the values from and into the new object. The '=' sign is the copy operator, and it will call the overloaded '=' operator, which is the copy assignment operator. 
    
    Now, in the copy assignment operator, you want to do 3 main things: 
    
        1) check to make sure you are not copying to the same location... which will be bad
        2) copy over the variables that do NOT use resources, basically shallow copying. 
        3) copy over the variables that DO use resources, which is deep copying
    
    First, check to make sure you are not copying to the same location:
    
    if (this != &incomingObj) // done by checking to see if the addresses match... note the '&' (address-of) operator...
    {
        // copy logic goes here...
    }
    
    For the second step, it is pretty easy, you just take the non-resource variable, and copy the incoming object's data to it, like this:
    
        this->age = incomingObj.age;
        
    For the third step, it gets a bit more complicated. First, you want to deallocate any previously allocated memory, but you don't want to deallocate non existant memory because the copy constructor (used for copying NEW object) also calls the copy assignment operator, and hence may contain non-allocated memory. So first you want to check to make sure the resource variables are in a safe, empty state, usually done by checking nullptr status.
    
    if (this->name != nullptr)
    {
        delete[] this->name;
        this->name = nullptr;
    }
    
    Then, you want to allocate NEW memory based on the specifications for the program
    
    this->name = new char[incomingObj.name_size + 1];
    
    Then, you want to deep copy the data...
    
    for (int i = 0; i < incomingObj.name_size; i++)
    {
        this->name[i] = incomingObj.name[i];
    }
    
    // or make your life easier and do this:
    std::strncpy(this->name, incomingObj.name, incomingObj.name_size];
    
    this->name[incomingObj.name_size] = '\0'; // don't forget to cap off char arrays!
    
    And finally, once you've done copying both non-resource and resource dependant variables, return a reference to the current object:
    
    return *this;
    
    Now if this were a move constructor or move assignment operator, you would do everything above, and then set the incoming object's data members to a safe empty state and deallocate memory for all resource pointers. But that'll come later. 
    
    
Issues that caused me difficulty in this workshop
*************************************************

This workshop was fairly straight-forward and simple. I've worked with copy constructors/assignment-operators numerous times before, so it wasn't really that complicated. A nasty little bug that I encountered however was in the += operator overload, where I tried to append the new object to the position of m_cnt instead of (m_cnt - 1). I forgot that arrays were counted starting at zero and spent a good 15 minutes dealing with that before I remembered. After I got that sorted out the program compiled fine and I was done. 
