/*************************************************/
/*  Student:    Yathavan Parameshwaran           */
/*  Student #:  070 692 140                      */
/*  Assignment: Final Project: MS6: reflect.txt  */
/*  Course:     OOP244 (retake)                  */
/*  Professor:  Andrei Sajeniouk                 */
/*  Date:       August 15, 2020                  */
/*************************************************/
/*************************************************/
/* I have done all the coding by myself and only */ 
/*  copied the code that my professor provided   */
/*  to complete this program.                    */
/*************************************************/


Topics Learned
**************

Inheritance
***********

Interitence is a cornerstone of object oriented programming. Inheritence 
greatly simplified object oriented programming by allowing classes to be 
"reusable". This is done by creating a form of "structural relationships" 
between classes. The relationship can be thought of as a parent-child 
relationship. The child inherits certain "traits" from the parent. Now, in 
programming terms, this means that the child class can inherit certain things 
from the parent class; and the things it can inherit can be controlled by an 
access specifier.

Another word for parent can be "base", and child can also be called "derived". 
Inheritance is great because when you are designing complex applications using 
object oriented programming and have multiple objects with similarities, you 
can have one dedicated class to define the same structure for the multiple 
objects, then smaller more lightweight classes that contain the specific data 
members/methods required for each individual object.


Resources
*********

Simply put, a class with a resource is basically a class which has a 
dynamically allocated pointer as a data member. It is called a "resource" 
because it borrows "resources" from the host ocmputer like memory and 
processing power. When you allocate memory for a pointer, you are using up 
resources from the host computer, hence it is called class with resource.

Deep Copying: There are two methods of copying, shallow and deep. Shallow 
copying is primarily reserved for data members that do not use up a host's 
resources. It is very simple copying, such as x1 = y1. Now, the other method is 
called deep copying. Deep copying is used whenever you need to copy data 
members that use resources, like pointers. You can do shallow copying on 
resource data members, but instead of copying values, it will simply copy the 
address of the original pointer that points to the values. This is not good, 
because if the original pointer changes or deletes the data, the pointer that 
is pointing to the original data's locations will reflect those changes, 
causing error. Deep copying is good because you actually copy over the data 
from the original pointer to the intended copy pointer. Deep copies of a class' 
data members are done through copy constructors and copy assignment operators, 
two topics that I will discuss next.

Copy Constructors & Copy Assignment Operators: Copy constructors and copy 
assignment operators are pretty much the same thing. Except when it isn't. Copy 
constructors are used for copying an object to a new object of the original 
type. Copy assignment operators are used to copy an object to an existing 
object of the original type. When I program, I tend to just call the copy 
assignment operator from the copy constructor, because they contain pretty much 
the same logic, but different use cases. In the copy constructor, I just do 
this: `*this = incomingObj;`. The "this" is a pointer to the current object, 
and since it is the copy constructor, it will normally refer to the NEW object. 
The incomingObj is the object that we want to copy the values from and into the 
new object. The '=' sign is the copy operator, and it will call the overloaded 
'=' operator, which is the copy assignment operator.


Polymorphism
************
Virtual functions and abstract base classes both fall under the heading of
polymorphism. Polymorphism is one of the four cornerstones of object oriented
programming, the other three being Encapsulation, Inheritence, and Abstraction.

Polymorphism is another word for "many forms". In programming terms, or more
specifically in object oriented programming, this means that an object can go
through many different states. This is where virtual functions come into play.
Virtual functions are an example of something called "inclusion polymorphism".
These types of functions are member functions (remember, functions of a class),
and is written to be redefined in any classes that in a sense "inherit" from
the base (virtual) class.

Now, to better explain virtual functions, we must first delve deeper into
binding. There are two types of binding: static and dynamic. Static binding is
practically the "default" binding. This is when the compiler matches a specific
function call with a specific function. For example if I had a function called
printLine(), the compiler will search the scope of all files included and use
the first definition that matches the function signature of the call. Now,
dynamic binding is when the programmer manually specifies which function the
compiler should match with the function call. To use dynamic binding, you must
specify the function with the keyword "virtual".



Difficulties Faced
******************

The project was quite easy all over. The milestone 6 was also easy, but due to 
medical circumstances I wasn't able to submit it on time. But the material 
itself was easy enough to understand and complete. The fun part of the project
was putting all the milestones together into a single program. All these 
milestones were like small programs each, and putting them all together to form
the final big program was the Power Rangers Megazord moment of programming.
